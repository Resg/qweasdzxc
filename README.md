# DZ  
## Краткое руководство  
### Входные данные  
Входные данные задаются колличеством задач, затем их список, затем колличество методов и их веса, и сами методы с колличество задач, которые они решают, и сами задачи.   
___Например___ :
8 0 1 2 3 4 5 6 7
4 3 1 4 5
2 0 1
3 1 4 5
4 2 3 6 7
4 1 4 6 7
### Выходные данные  
Для выходных данных требуется указывать выходной файл, в котором будет отображен результат работы программы. 
___Пример выходных данных___ :
3
0 2 1    
где ___3___- колличество методов, а ___0 2 1___ - сами методы.
### Запуск программы  
Программа принимает 3 аргумента: файл с входными данными, затем файл, куда будет записан результат работы программы, а так же последний файл с текстовыми данными, необходимый для проверки правильности выполнения работы.
Пример компиляции: ___C:\Users\mixan\source\repos\DZ1\Debug\DZ1.exe C:\Users\mixan\Desktop\Test\Initial_data\1.dat C:\Users\mixan\Desktop\text.txt C:\Users\mixan\Desktop\Test\output\1.tst___  
# Тесты  
В тестовый файл надо записать колличество методов и сами методы.
___Например___ : 
3
0 2 1   
Суть алгоритма заключается в поиске покрытия задач методами с весами. Реализуется как поиск минимальной ДНФ для булевых функций.
Алгоритм состоит из следующих этапов.  
* ___Склейка___. Пусть K1 и K2 - две элементарные конъюнкции, входящие в исходную СДНФ Ф, которая представляет функцию f, причем для некоторого переменного x и некоторой элементарной конъюнкции K выполняются равенства K1 = xK и K2 = !xK.  Токгда имеем, согласно тождествам булевой алгебры, K1 U K2 = xK1 U !xK2 = (x U !x)K = K. Мы получаем элементарную конъюнкцию K, которая содержит на один литерал меньше, чем К1 и К2, и является, как и обе конъюнкции К1 и К2, импликантой f. Образно говоря, мы "склеили" две импликанты в одну, в которой число литералов на единицу меньше. Применяем склейку до тех пор, пока не окажется , что для некоторого k в  ДНФ Фk, уже нельзя склеить никакие две элементарные конъюнкции.  
* ___Поглощение___. Пусть K1 и K2 - две элементарные конъюнкции, входящие в исходную СДНФ Ф, которая представляет функцию f, причем для некоторого переменного x и некоторой элементарной конъюнкции K выполняются равенства K1 = x1x2 и K2 = x1x2x3.  Токгда имеем, согласно тождествам булевой алгебры, K1 U K2 = x1x2 U x1x2x3 = (1 U x3)x1x2 = x1x2. Мы получаем элементарную конъюнкцию K1, которая содержит на один литерал меньше, чем К2, и является, как и обе конъюнкции К1 и К2, импликантой f. Образно говоря, мы "поглотили" литерал, и получилась импликанта, в которой количество литералов на единицу меньше. Применяем плглощение до тех пор, пока не окажется , что для некоторого k в  ДНФ Фk, уже нельзя поглотить никакой литерал.   
* ___Импликантная матрица___. Она заполняется следующим образом. Члены СДНФ заданной функции вписываются в столбцы, а в строки — простые импликанты, то есть члены сокращённой формы. Отмечаются столбцы членов СДНФ, которые поглощаются отдельными простыми импликантами.В следующей таблице простая импликанта !x1!x2!x3 поглощает члены !x1!x2!x3!x4 и !x1!x2!x3x4.  
![](/img/2.png)  

* ___Определение ядра___.Входящие в ядро импликанты легко определяются по импликантной матрице. Для каждой из них имеется хотя бы один столбец, перекрываемый только данной импликантой.

* ___Ищем минимальное покрытие матрицы___. Для получения минимальной формы достаточно выбрать из импликантов, не входящих в ядро, такое минимальное их число с минимальным количеством букв в каждом из этих импликант, которое обеспечит перекрытие всех столбцов, не перекрытых членами ядра.

В итоге получаем минимальную ДНФ.

# Алгоритм
Мой алгоритм работает в несколько этапов.    
* Составление импликантной матрицы.  
* Нахождение ядра.  
* Поиск минимального покрытия.  
  
1) Составление импликантной матрицы. Выполняется с помощью ___O(n^2)___ операций сравнений импликант в матрице. Каждое такое сравнение выполняется за ___O(log(n))___ . Получаем вычислительную сложность ___O((n^2)log(n))___ . По памяти матрица займет ___O(n^2)___ ячеек.  
2) Нахождение ядра. Мы проходим ___O(n)___ столбцов импликатной матрицы, каждый из которых имеет ___O(n)___ ячеек. Сложность этого этапа ___O(n^2)___ . По памяти в хужшем храним все простые импликанты, которых ___O(n)___ и каждая из которых длиной ___O(log(n))___ . Получаем сложность по памяти ___O(nlog(n))___ .  
3) Поиск минимального покрытия. Точную оценку, в общем, случаи здесь дать очень сложно. Поэтому оценим с помощью условных переменных hi. Получим, что сложность равна ___O(h1h2*...*h(n))___ , где hi - кол-во импликант. По памяти в хужшем храним все простые импликанты, которых ___O(n)___ и каждая из которых длиной ___O(log(n))___ . Получаем сложность по памяти ___O(nlog(n))___ .

# Логика программы  
Сначала запускается функция `main`. В ней открывются файлы с входными данными и для записи выходных. Затем создается объект `metod`. В `metod` вызывается поле `solList`, которое создает вектор методов решений, который записывается в  файл с выходными данными. Потом происходит проверка результатов.
