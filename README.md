# DZ  
## Краткое руководство  
### Входные данные  
Входные данные задаются колличеством задач, затем их список, затем колличество методов и их веса, и сами методы с колличество задач, которые они решают, и сами задачи.   
___Например___ :
8 0 1 2 3 4 5 6 7
4 3 1 4 5
2 0 1
3 1 4 5
4 2 3 6 7
4 1 4 6 7
### Выходные данные  
Для выходных данных требуется указывать выходной файл, в котором будет отображен результат работы программы. 
___Пример выходных данных___ :
3
0 2 1    
где ___3___- колличество методов, а ___0 2 1___ - сами методы.
### Запуск программы  
Программа принимает 3 аргумента: файл с входными данными, затем файл, куда будет записан результат работы программы, а так же последний файл с текстовыми данными, необходимый для проверки правильности выполнения работы.
Пример компиляции: ___C:\Users\mixan\source\repos\DZ1\Debug\DZ1.exe C:\Users\mixan\Desktop\Test\Initial_data\1.dat C:\Users\mixan\Desktop\text.txt C:\Users\mixan\Desktop\Test\output\1.tst___  
# Тесты  
В тестовый файл надо записать колличество методов и сами методы.
___Например___ : 
3
0 2 1   
Суть алгоритма заключается в поиске покрытия задач методами с весами. Реализуется как поиск минимальной ДНФ для булевых функций.

# Алгоритм
Мой алгоритм работает в несколько этапов.    
* Составление импликантной матрицы.  
* Нахождение ядра.  
* Поиск минимального покрытия.  
  
1) Составление импликантной матрицы. Выполняется с помощью ___O(n^2)___ операций сравнений импликант в матрице. Каждое такое сравнение выполняется за ___O(log(n))___ . Получаем вычислительную сложность ___O((n^2)log(n))___ . По памяти матрица займет ___O(n^2)___ ячеек.  
2) Нахождение ядра. Мы проходим ___O(n)___ столбцов импликатной матрицы, каждый из которых имеет ___O(n)___ ячеек. Сложность этого этапа ___O(n^2)___ . По памяти в хужшем храним все простые импликанты, которых ___O(n)___ и каждая из которых длиной ___O(log(n))___ . Получаем сложность по памяти ___O(nlog(n))___ .  
3) Поиск минимального покрытия. Точную оценку, в общем, случаи здесь дать очень сложно. Поэтому оценим с помощью условных переменных hi. Получим, что сложность равна ___O(h1h2*...*h(n))___ , где hi - кол-во импликант. По памяти в хужшем храним все простые импликанты, которых ___O(n)___ и каждая из которых длиной ___O(log(n))___ . Получаем сложность по памяти ___O(nlog(n))___ .

# Логика программы  
Сначала запускается функция `main`. В ней открывются файлы с входными данными и для записи выходных. Затем создается объект `metod`. В `metod` вызывается поле `solList`, которое создает вектор методов решений, который записывается в  файл с выходными данными. Потом происходит проверка результатов.
